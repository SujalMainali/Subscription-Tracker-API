import mongoose from "mongoose"
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import {JWT_SECRET,JWT_EXPIRES_IN} from "../config/env.js";
import User from "../models/user.model.js";

export const signUp= async (req,res,next) =>{
    //Implement sign up logic here to communicate with the database 
    const session=await mongoose.startSession();  //This is a method of the mongoose library, it stars a mongoose session of interacting with the database
    //We only use secessions when writing to database as we need to ensure that incomplete data is not entered in the database
    //Also we are using sessions because we using the database with two or more commands. Either all of them needs to be done or taken back. Thus, session is used
    session.startTransaction();

    try {
        const { name, email, password } = req.body;     //We get these data when post request is made by the client

        const existingUser= await User.findOne({ email })  //Check if the user with the same email exists. This is same as email:email
        if (existingUser) {
            const error = new Error("User already exists");
            error.statusCode = 409;
            throw error;
        }

        //Now for saving the password of the user to the database. We dont save the password in plain text as it is risky.
        //We generate a hash for the password and save that hash to the database.
        //We can use the same hashing and reversing algorithm to check if the password is correct or not.

        const salt=await bcrypt.genSalt(10); 
        const hashedPassword=await bcrypt.hash(password,salt); //We hash the password with the salt
        
        //This is the mongoose code to create a new user in the database
        const newUsers= await User.create([{name,email,password:hashedPassword}],{session})

        //This is a  JSON web token. It is used to authenticate the user. It is a string that is generated by the server and sent to the client. The client sends this token back to the server for authentication while making API calls which are limited only to that USER.
        const token= jwt.sign(
            {userID: newUsers[0]._id}, //This encoded the userID into the token
            JWT_SECRET,                //This encoded the server secret into the token to verify that the token was generated from this server
            {expiresIn: JWT_EXPIRES_IN}) //this provides an expiration time to the token. After this time, the token will not be valid and the user will have to sign in again to get a new token


        await session.commitTransaction();
        session.endSession();

        res.status(201).json({
            success:true,
            message:"User created successfully",
            data:{
                token,
                user:newUsers[0],
            }
        })
    }
    catch (error) {
        await session.abortTransaction();
        session.endSession();
        next(error);
    } 
}

export const signIn= async (req,res,next) =>{
    try{
        const {email,password}=req.body;
        //First we check if the user exists or not
        const user=await User.findOne({email}).select("+password"); //We select the password field as it is not selected by default in the user model. We need to select it to check if the password is correct or not. 
        
        if(!user){
            const error=new Error("User not found");
            error.statusCode=404;
            throw error;
        }

        const isPasswordCorrect=await bcrypt.compare(password,user.password); //We compare the password with the hashed password in the database. This will return true or false

        if(!isPasswordCorrect){
            const error=new Error("Incorrect password");
            error.statusCode=401;
            throw error;
        }

        const token= jwt.sign({userID:user._id},JWT_SECRET,{expiresIn:JWT_EXPIRES_IN})

        res.status(201).json({
            success:true,
            message:"Signed in",
            data:{
                token,
                Info:user
            }
    })

    }
    catch (error) {

        next(error);
    }
}

export const signOut= async (req,resizeBy,next) =>{
    
}